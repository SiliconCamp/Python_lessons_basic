#!/usr/bin/python3

"""
== Лото ==

Правила игры в лото.

Игра ведется с помощью специальных карточек, на которых отмечены числа, 
и фишек (бочонков) с цифрами.

Количество бочонков — 90 штук (с цифрами от 1 до 90).

Каждая карточка содержит 3 строки по 9 клеток. В каждой строке по 5 случайных цифр, 
расположенных по возрастанию. Все цифры в карточке уникальны. Пример карточки:

--------------------------
    9 43 62          74 90
 2    27    75 78    82
   41 56 63     76      86 
--------------------------

В игре 2 игрока: пользователь и компьютер. Каждому в начале выдается 
случайная карточка. 

Каждый ход выбирается один случайный бочонок и выводится на экран.
Также выводятся карточка игрока и карточка компьютера.

Пользователю предлагается зачеркнуть цифру на карточке или продолжить.
Если игрок выбрал "зачеркнуть":
	Если цифра есть на карточке - она зачеркивается и игра продолжается.
	Если цифры на карточке нет - игрок проигрывает и игра завершается.
Если игрок выбрал "продолжить":
	Если цифра есть на карточке - игрок проигрывает и игра завершается.
	Если цифры на карточке нет - игра продолжается.
	
Побеждает тот, кто первый закроет все числа на своей карточке.

Пример одного хода:

Новый бочонок: 70 (осталось 76)
------ Ваша карточка -----
 6  7          49    57 58
   14 26     -    78    85
23 33    38    48    71   
--------------------------
-- Карточка компьютера ---
 7 87     - 14    11      
      16 49    55 88    77    
   15 20     -       76  -
--------------------------
Зачеркнуть цифру? (y/n)

Подсказка: каждый следующий случайный бочонок из мешка удобно получать 
с помощью функции-генератора.

Подсказка: для работы с псевдослучайными числами удобно использовать 
модуль random: http://docs.python.org/3/library/random.html

"""

# РЕШЕНИЕ:
# Данный проект уже явно требует некоторого подобия документации, поэтому я сначала
# изложу здесь свои идеи, предполагаемые узлы и объяснение принципа работы.
# NB: Кстати, я против использования тройных кавычек для комментирования - не совсем понял зачем так поступили в ДЗ.
#
# Прежде всего пойдем от подсказки про модуль random, нет ли там какой-то полезной истории.
# Пока идея только в том, чтобы генерировать список уникальных (неповторяющихся бочонков)
# Средствами модуля - random.sample
#
# Теперь продумаем логику раунда:
# 1. Выводим на экран инструкцию, что человек играет против компьютера, правила и т.п. (один раз при запуске)
# 2. Сгененируем карточку для игрока и для компьютера
# 3. Сгенерируем последовательность бочонков. Да, это не так как реальной игре (рука в мешке), но проще и быстрее.
# 4. Дальше у нас должен быть основной цикл раунда, который прервется только в следующих пяти случаях:
#    - выбрал зачеркнуть, а такого номер нет
#    - выбрал продолжить, а номер-то был
#    - решил сам выйти (в условии этого нет, но так красивее)
#    - вся карточка компьютера заполнилась
#    - вся карточка игрока заполнилась
# 5. Выводим на экран, что игра завершена.
#
# Теперь собственно о логике внутри основного цикла. Нам понадобится следующие инструменты:
# 1. Содержится ли бочонок в карте
# 2. Достигнут ли конец карты (все цифры зачеркнуты)
# 3. Создать список бочонков (пока пойдем от идеи подсказки и заранее сгенерированного сипска)
# 4. Достать бочонок из мешка (допустим .pop из списка)
# 5. Генератор карточки и какой-то способ ее форматирования
#

# Выносим импорты и константы в начало, как по стандарту
import random # Нужен для генерации бочонков
import copy # Нужен для генерации внешнего вида карточки

# Константы размеров карточки.
MAX_BARREL = 90
DIGITS_IN_CARD = 15
DIGITS_IN_LINE = 5


# Итак, для начала сгенерируем список бочонков и напишем функцию выдачи очередного бочонка:
def make_barr_list():
    return random.sample(range(1, MAX_BARREL + 1), 90)


def take_barrel(barr_list):
    return barr_list.pop()


# Теперь нужно создать карточки и красиво их вывести на экран. Делаем генератор и форматированный вывод
def make_card():
    num_comb = random.sample(range(1, MAX_BARREL + 1), DIGITS_IN_CARD)
    card = [sorted(num_comb[i:i + DIGITS_IN_LINE]) for i in range(0, len(num_comb), DIGITS_IN_LINE)]
    return card


def display_card(card):
    card = copy.deepcopy(card)  # тут воспользуемся хитрым модулем copy, который скопирует исходник без изменений
    placeholders = ' '.join(['{:>2}' for i in range(9)])  # как было в задаче с фруктами, делаем 9 ячеек
    for line in card:
        for space in ' ' * 4:
            line.insert(random.randint(0, len(line) - 1), space)  # Вставляем спейсеры в случайные места карточки
    return [placeholders.format(*line) for line in card]


# Зачеркиваем бочонки в карточке
def stroke_card(card, barrel):
    for line in card:
        yield ['-' if x == barrel else x for x in line]


# Проверяем остались ли еще незачеркнутые бочонки
def is_empty(card):
    for line in card:
        for elt in line:
            if elt != '-':
                return False
    return True


# Проверяем, содержится ли бочонк в карточке
def barr_in_card(card, barrel):
    return barrel in [barrel for line in card for barrel in line]


# Основной цикл раунда
def play_round():

    player_card = make_card()
    comp_card = make_card()
    barrels = make_barr_list()
    while True:  # check if all digits are crossed
        next_barrel = take_barrel(barrels)
        print('\nВыпал бочонок: {}. Всего осталось: {}'.format(next_barrel, len(barrels)))
        print("{0} Твоя карточка {0}\n{1}\n{2}\n{3}".format('-' * 6, *display_card(player_card)))
        print("{0} Карточка компьютера {0}\n{1}\n{2}\n{3}".format('-' * 5, *display_card(comp_card)))
        answ = 'a'
        while answ not in 'ynq':
            answ = input("В твоей карточке есть этот бочонок? \n "
                         "y - да, есть (зачеркнуть) \n "
                         "n - нет такого бочонка \n "
                         "q - выход")
        if answ == 'q':
            break
        elif (answ == 'y' and barr_in_card(player_card, next_barrel)) or (answ == 'n' and not barr_in_card(player_card, next_barrel)):
            print("Отлично!")
        else:
            print("Ты проиграл!")
            break
        player_card = list(stroke_card(player_card, next_barrel))
        comp_card = list(stroke_card(comp_card, next_barrel))
        if is_empty(player_card):
            print('Ты заполнил всю карточку!')
            break
        if is_empty(comp_card):
            print('компьютер заполнил свою карточку!')
            break


print('Инструкция: \nЦель игры - зачеркнуть все бочонки в своей карточке раньше, чем это сделает компьютер')

play_round()